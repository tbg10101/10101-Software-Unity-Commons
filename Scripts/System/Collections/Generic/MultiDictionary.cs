using JetBrains.Annotations;

namespace System.Collections.Generic {
	/// <summary>
	/// Does not store duplicate key-value pairs. Adding a new key-value pair equal to an existing key-value pair has no effect.
	/// </summary>
	public sealed class MultiDictionary<TKey, TValue> : Dictionary<TKey, HashSet<TValue>> {
		/// <summary>
		/// Stores a key-value pair in the MultiDictionary.
		/// </summary>
		public void Add (TKey key, TValue value) {
			HashSet<TValue> collection;

			if (TryGetValue(key, out collection)) {
				collection.Add(value);
			} else {
				collection = new HashSet<TValue> {value};
				base[key] = collection;
			}
		}

		/// <summary>
		/// Stores a KeyValuePair pair in the MultiDictionary.
		/// </summary>
		public void Add (KeyValuePair<TKey, TValue> entry) {
			Add(entry.Key, entry.Value);
		}

		/// <summary>
		/// Stores a key-value pair in this MultiDictionary for each of values, all using the same key.
		/// </summary>
		public void AddRange (TKey key, IEnumerable<TValue> values) {
			foreach (TValue value in values) {
				Add(key, value);
			}
		}

		/// <summary>
		/// Stores key-value pairs in this MultiDictionary for each of key-value pairs in the input Dictionary.
		/// </summary>
		public void AddRange (IDictionary<TKey, TValue> dict) {
			foreach (TKey key in dict.Keys) {
				Add(key, dict[key]);
			}
		}

		/// <summary>
		/// Stores key-value pairs in this MultiDictionary for each of key-value pairs in the input MultiDictionary.
		/// </summary>
		public void AddRange (MultiDictionary<TKey, TValue> dict) {
			foreach (KeyValuePair<TKey, TValue> entry in dict) {
				Add(entry);
			}
		}

		/// <summary>
		/// Returns a view of this MultiDictionary as an IDictionary from each distinct key to the collection of that key's associated values.
		/// </summary>
		public IDictionary<TKey, HashSet<TValue>> AsDictionary () {
			return new Dictionary<TKey, HashSet<TValue>>(this);
		}

		/// <summary>
		/// Returns a view collection containing the value from each key-value pair contained in this MultiDictionary, without collapsing duplicates (so Values.Count == Count).
		/// Changes to the returned collection will not update the underlying MultiDictionary, and vice versa.
		/// The iterator generated by the returned collection traverses the values for one key, followed by the values of a second key, and so on.
		/// </summary>
		public new ICollection<TValue> Values {
			get {
				List<TValue> values = new List<TValue>();

				foreach (ICollection<TValue> collection in base.Values) {
					values.AddRange(collection);
				}

				return values;
			}
		}

		/// <summary>
		/// Returns the collection of values associated with key in this MultiDictionary, if any.
		/// Note that when ContainsKey(key) is false, this returns an empty collection, not null.
		/// Changes to the returned collection will update the underlying MultiDictionary, and vice versa.
		/// </summary>
		public new HashSet<TValue> this[TKey key] {
			get {
				HashSet<TValue> collection;

				if (TryGetValue(key, out collection)) {
					return collection;
				}

				collection = new HashSet<TValue>();
				base[key] = collection;

				return collection;
			}
		}

		/// <summary>
		/// Returns the number of key-value pairs in this MultiDictionary.
		/// </summary>
		public new int Count {
			get {
				int count = 0;

				foreach (ICollection<TValue> collection in base.Values) {
					count += collection.Count;
				}

				return count;
			}
		}

		/// <summary>
		/// Hiding the Dictionary.Remove(TKey) method.
		/// </summary>
		[UsedImplicitly]
		private new bool Remove(TKey key) {
			return false;
		}

		/// <summary>
		/// Removes a single key-value pair with the key and the value from this MultiDictionary, if such exists.
		/// </summary>
		public bool Remove (TKey key, TValue value) {
			return this[key].Remove(value);
		}

		/// <summary>
		/// Removes all values associated with the key.
		/// Once this method returns, key will not be mapped to any values, so it will not appear in Keys,AsDictionary(), or any other views.
		/// </summary>
		public bool RemoveAll (TKey key) {
			return base.Remove(key);
		}

		/// <summary>
		/// Returns true if this MultiDictionary contains at least one key-value pair with the value value.
		/// </summary>
#pragma warning disable 109
		public new bool ContainsValue (TValue value) {
			foreach (ICollection<TValue> collection in base.Values) {
				if (collection.Contains(value)) {
					return true;
				}
			}

			return false;
		}
#pragma warning restore 109

		public new IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator () {
			List<KeyValuePair<TKey, TValue>> list = new List<KeyValuePair<TKey, TValue>>();

			foreach (TKey key in Keys) {
				foreach (TValue value in base[key]) {
					list.Add(new KeyValuePair<TKey, TValue>(key, value));
				}
			}

			return list.GetEnumerator();
		}

		[UsedImplicitly]
		private void CleanUp() {
			List<TKey> keysToRemove = new List<TKey>();

			Keys.ForEach(key => {
				if (base[key].Count <= 0) {
					keysToRemove.Add(key);
				}
			});

			keysToRemove.ForEach(key => base.Remove(key));
		}
	}
}
